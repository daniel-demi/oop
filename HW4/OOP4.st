Dictionary subclass: #EnumDictionary	instanceVariableNames: 'enumClass'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!EnumDictionary methodsFor: 'instance-methods' stamp: 'dd 6/10/2021 12:31'!add: anAssociation	| index |	((anAssociation key) isKindOf: enumClass) ifFalse: [self error: 'this EnumDictionary only accepts ',enumClass,'''s values as keys'].	index := self scanFor: anAssociation key.	(array at: index)		ifNil: [ self atNewIndex: index put: anAssociation ]		ifNotNil: [ :element |	element value: anAssociation value ].	^anAssociation	! !!EnumDictionary methodsFor: 'instance-methods' stamp: 'dd 6/10/2021 11:13'!getEnum	^enumClass.! !!EnumDictionary methodsFor: 'instance-methods' stamp: 'dd 6/10/2021 11:10'!initialize 	enumClass := nil.	^self.! !!EnumDictionary methodsFor: 'instance-methods' stamp: 'dd 6/10/2021 12:30'!setEnum: anEnumClass	(anEnumClass superclass == OOPEnum) ifFalse: [self error: '',anEnumClass, ' is not an Enum'].	(enumClass == nil) ifFalse: [self error: 'the Dictionary''s Enum is already defined with ', enumClass].	enumClass := anEnumClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EnumDictionary class	instanceVariableNames: ''!!EnumDictionary class methodsFor: 'class-methods' stamp: 'dd 6/10/2021 12:30'!onEnum: anEnumClass	| newDict |	(anEnumClass superclass == OOPEnum ) ifFalse: [self error: anEnumClass, ' is not an Enum'].	newDict := self new.	newDict setEnum: anEnumClass.	^newDict.! !Object subclass: #OOPEnum	instanceVariableNames: 'values lazyInitialization'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPEnum class	instanceVariableNames: 'values lazyInitialization'!!OOPEnum class methodsFor: 'class-methods' stamp: 'dd 6/15/2021 22:12'!addSwitch	| subValues |	subValues := OOPEnum allSubsequences: values currentSubSeq: {}.	subValues do: [:currVals |		| toCompile firstVal |		(currVals size == 0) ifFalse: [			firstVal := (currVals at: 1).			toCompile := 'switch_case_', firstVal, ': ', firstVal, 'Block '.			(currVals size == 1) ifFalse: [				(2 to: (currVals size)) do: [:x |					| nextVal |					nextVal := (currVals at: x).					toCompile := toCompile, 'case_', nextVal, ': ', nextVal, 'Block '.					]				].			(currVals size < values size) ifTrue: [				toCompile := toCompile , 'default: defaultBlock				'.			].			currVals do: [:val |				toCompile := toCompile , '(self == (self class superclass ',val,' )) ifTrue: [',val,'Block value. ^self].				'.				].			(currVals size < values size) ifTrue: [				toCompile := toCompile, 'defaultBlock value'.			].			self compile: toCompile.		]	] ! !!OOPEnum class methodsFor: 'class-methods' stamp: 'dd 6/8/2021 19:28'!compile: aSourceCode	| superClass codeSelector tempClass |	superClass := self superclass .	(superClass superclass = OOPEnum) ifTrue: [		tempClass := (ClassBuilder new) 		superclass: Object		subclass:  #TMP		instanceVariableNames: ''		classVariableNames:  ''		poolDictionaries:  ''		category: ''.		tempClass compile: aSourceCode notifying: nil.		codeSelector := (tempClass selectors ) at: 1.		(superClass includesSelector: codeSelector) ifFalse: [			tempClass removeSelector: codeSelector.			self error: codeSelector, ' does not override a method from ', superClass			] 		ifTrue: [			tempClass removeSelector: codeSelector.			^self compile: aSourceCode notifying: nil			]		] 	ifFalse: [		^self compile: aSourceCode notifying: nil		].! !!OOPEnum class methodsFor: 'class-methods' stamp: 'dd 6/4/2021 15:38'!new	self error: 'You can''t create an instance of ' , self name.! !!OOPEnum class methodsFor: 'class-methods' stamp: 'dd 6/4/2021 15:56'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategory	self error: 'You must specify ' , aSubclassName , '''s values'.! !!OOPEnum class methodsFor: 'class-methods' stamp: 'dd 6/15/2021 18:52'!subclass: aSubclassName values: valuesArr lazyInitialization: aBoolean initialize: initializeAsString instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	| newClass newClassClass valuesClassArr |	(self == OOPEnum ) ifFalse: [		self error: self name , ' is final!! It can''t be inherited'	].	newClass := (ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries 		category: aCategoryName.	newClass compile: initializeAsString.	newClassClass := newClass class.	valuesArr do: [:v | newClassClass addInstVarName: v].		newClassClass compile: 'setValuesArr		values := ', valuesArr.	newClass setValuesArr. 	"newClass removeSelector: 'setValuesArr'."	valuesClassArr := valuesArr collect: [:v | (ClassBuilder new)		superclass: newClass		subclass: ((aSubclassName,'_',v,'__') asSymbol)		instanceVariableNames: ''		classVariableNames: '' 		poolDictionaries: '' 		category: aCategoryName].	(aBoolean) ifFalse: [		| func |		func := 'initVals		'.		(1 to: valuesArr size) do: [:i |			| valName valClass |			valName := valuesArr at: i.			valClass := valuesClassArr at: i.			 func := func, valName , ':= ', valClass, 'basicNew initialize.		' ].		newClassClass compile: func.		newClass initVals.		valuesArr do: [:v | newClassClass compile: v, '			^',v].		] ifTrue: [		| func |			func := 'initVals			'.			valuesArr do: [:v | func := func , v , ' := nil.				'].			newClassClass compile: func.			newClass initVals.			(1 to: valuesArr size) do: [:i |				| valName valClass|				valName := valuesArr at: i.				valClass := valuesClassArr at: i.				newClassClass compile: valName, '				(',valName,' == nil) ifTrue: [				', valName, ' := ' , valClass,' basicNew initialize].				^', valName]		].		newClassClass compile: 'setLazyInitialization		lazyInitialization := ', aBoolean.	newClass setLazyInitialization.	^newClass.! !!OOPEnum class methodsFor: 'help-mothods' stamp: 'dd 6/10/2021 12:03'!allSubsequences: arr currentSubSeq: currSeq	| res tempSeq |	tempSeq := currSeq collect: [:x | x at: 1].	(arr size == 0) ifTrue: [^{tempSeq}].	res := OOPEnum allSubsequences: 	((2 to: (arr size)) collect: [:x | arr at: x]) currentSubSeq: currSeq, {{arr at: 1}}.	res := res, (OOPEnum allSubsequences: ((2 to: (arr size)) collect: [:x | arr at: x]) currentSubSeq: currSeq).	^res.! !